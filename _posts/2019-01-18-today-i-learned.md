---
layout: post
title: 오늘 배운것
date: 2019-01-18
excerpt: 나누기, db인덱스
image: ""
sitemap :
  changefreq : daily
  priority : 1.0
---



<div>
 <p>
  오늘은 나누기에 대해서 새로운것을 들었다. 나누기를 사용할때는 잘 생각해서 사용할것!
 </p>
 <h3>나누기를 사용할때</h3>
  <p>이미지가 2MB이상이면 비율을 반으로 줄일때 즉(width, height 크기를 반으로 줄여줄때)</p>
  <p>ex) width= width / 2, height = height / 2로 해주면 된다. 이렇게 그저 단순하게 나누기를 할때는 써도 상관이없다</p>
  
 <h3>나누기를 사용하지 않아야할때</h3>
    <p>파일사이즈가 1MB이상일때 함수를 타야하는구문을 만들어야할때</p>
    <p>ex) 이럴경우 나같은 경우는 if(file.length() / 1024 / 1024 > 1)로 만들었었다. 하지만 이렇게 했을 경우 만약 1.2MB이상일때로 변경이 된다면?<br/>
        소수점이 포함되어야한다면 어떻게 만들어야할까? 나눠지는수가 나누는 수보다 클경우 0이 나오는것은 당연하다...이럴경우 아주 복잡해진다.</br>
        그러므로 이러한 부분은 if(file.length() > 1 * 1024 * 1024)로 해준다면 위와같은 결과값이 나올것이다. 이때 1.2MB이상으로 변경이 된다면?<br/>
        1.2 * 1024 * 1024로 해주면 가능하다 
    </p>
    <p>
      갑작스럽게 서버가 느려졌던적이 있다. 이것은 로그인할때 이력을 남기는데 80만건이랬나 8만건이 되니까 느려진것이라고 했다. 이때 index설정에 대한것      <br/>을 물어보았는데...구현은 못하지만 목차같은 느낌으로 셀렉트시 빠르게 조회가 가능하다고만 말했다...ㅋㅋㅋㅋ그래서 나름 찾아보고 적어 놓으려고        한다.
    </p>
    <h3>Index란?</h3>
        <p>
            테이블에 저장된 데이터를 빠르게 조회하기 위한 데이터베이스 객체
        </p>    
    <h3>Index를 왜 사용 할까?</h3>
        <p>
            SQL서버에서 테이블을 만들고 데이터를 추가, 수정, 삭제 할때 데이터의 레코드는 내부적으로 아무런 순서없이 저장이됨.<br/>
            이때 데이터 저장영역을 Heap이라고 한다. Heap에서는 인덱스가 없는 테이블의 데이터를 찾을때 무조건 전체 페이지의<br/>
            처음 레코드부터 끝 페이지의 마지막 레코드까지 다 읽어서 검색조건과 비교한다 이 어찌 비효율적이란 말인가...<br/>
            이런식의 검색 방법은 테이블스캔 or 풀스캔이라고 함.<Br/>
            이럴 경우 양이 많은 테이블에서 일부의 데이터만 불러 올때 성능이 떨어진다. 즉 인덱스는 데이터를 select 할 때 빨리 찾기 위해 사용됨
        </p>
    <h3>Index 생성 시 고려할점</h3>
    <p>
        그렇다고 막 갖다 생성하는것은 아니다 where절과 join, order by 등과 관련된 컬럼중 사용 빈도가 높고 키 값의 선별도가 좋은<Br/>
        컬럼에 사용해야 한다. 사용빈도가 낮고 컬럼의 선별도가 낮은 ex) 컬럼값이 true/false, 성별(M/F)등에는 사용하지 않는것이 좋음.<br/>
        테이블이 작거나 자주 갱신 될 때도 사용 x
        선택한 키의 검색 일치율이 10% 미만일경우 Index사용이 좋으나, 그 이상일 경우는 풀스캔이 더 좋을수도 있다.
        <Br/>
        ex) 테이블 내 100개 데이터중 pk=1 을 검색했을때, 1개의 데이터가 나올경우 1/100 = 0.01 즉 1%의 일치율
        <br/>
        책에 비유하면 클러스터 인덱스는 찾고자한느 페이지를 바로 찾는것이고 논 클러스터 인덱스는 목차를 먼저 확인한 다음, 목차에서<br/>
        찾고자 하는 페이지를 찾아가는것. 테이블 스캔은 처음부터 한 장씩 넘기면서 찾는 방식
    </p>
    <h3>팁</h3>
    <ul>
        <li>where절에서 자주 사용하는 컬럼/li>
        <li>like '%~~~~~~~~~'는 조심(table scan이여서 성능감소) %는 뒤에만 사용</li>
        <li>between A and B(클러스터 인덱스 유리) - 범위 쿼리문에서는 클러스터 인덱스가 유리 but 클러스터 인덱스는 테이블당 1개만 가질수있다는 단           점
        </li>
        <li>order by에 항상 또는 자주 사용되는 컬럼</li>
        <li>join으로 자주 사용되는 컬럼</li>
        <li>Foreign key (1:1매핑)이 많을때 -> 클러스터,논클러스터 둘다 상관 x</li>
        <li>Foreign key (1:N매핑)이 많을때 -> 클러스터 인덱스 사용</li>
        <li>100만건의 데이터 중 10건의 데이터 조회 -> 찾는 건이 적은 컬럼에 인덱스를 걸어줘야함 <br/>
            ex) 중복이 많은 컬럼(예를들어, 성별)에는 거는것이 아니다.<br/>
                조회되는 건 수가 많으면 인덱스를 걸지 않고 table scan이 더나은편
        </li>
        <li>not 연산자는 긍정문으로 변경</li>
        <li>insert, delete등 데이터의 변경이 많은 컬럼은 인덱스를 걸지 않는편이 좋다.
            <br/> 인덱스를 만드는데 시간과 저장공간이 소비되고 만들고 난후에도 추가적인 공간이 필요<br/>
            데이터를 변경(insert, update, delete)를 하면 (특히 insert)인덱스를 다시 조정해야하기 때문에 자원이 많이 소모됨
        </li>
    </ul>
    <h3>Index 생성</h3>
    <p>
        인덱스에는 크게 clustered와 nonclustered인덱스로 나눌 수 있다.
    </p>
    <h3>clustered인덱스</h3>
    <ul>
        <li>물리적 정렬로 DB에 데이터를 입력 시 이것을 기준으로 입력이 된다.</li>
        <li>한 테이블에 오직 하나만 존재 할 수 있으며 table을 열었을 때 order by를 사용하지 않아도 데이터가 clustered인덱스에 따라 정렬이 되있음          </li>
        <li>
            물리적 정렬이 되어 있는 만큼 가장 빠른 처리를 한다.
        </li>
    </li>
    <h3>nonclustered인덱스</h3>
    <ul>
        <li>clustered인덱스와는 달리 중복된 값을 가지면 한 테이블에 여러 개를 생성 할 수 있다.</li>
    </ul>
    <h3>unique</h3>
    <ul>
        <li>말 그대로 중복을 허용하지 않는 값을 보호 할때 사용</li>
        <li>자주사용하는 primary key의 경우에는 clustered와 unique 특성을 갖게하는 제약키이다.</li>
    </ul>
    <p>출처 <a href="http://brownbears.tistory.com/57">http://brownbears.tistory.com/57</a></p>
</div>
